# 三大范式与反范式
1. 第一范式

确保数据表中每列（字段）的原子性。
如果数据表中每个字段都是不可再分的最小数据单元，则满足第一范式。

例如：user用户表，包含字段id,username,password

2. 第二范式

在第一范式的基础上更进一步，目标是确保表中的每列都和主键相关。
如果一个关系满足第一范式，并且除了主键之外的其他列，都依赖于该主键，则满足第二范式。

例如：一个用户只有一种角色，而一个角色对应多个用户。则可以按如下方式建立数据表关系，使其满足第二范式。
user用户表，字段id,username,password,role_id
role角色表，字段id,name
用户表通过角色id（role_id）来关联角色表

3. 第三范式

在第二范式的基础上更进一步，目标是确保表中的列都和主键直接相关，而不是间接相关。**禁止非主属性传递依赖**

例如：一个用户可以对应多个角色，一个角色也可以对应多个用户。则可以按如下方式建立数据表关系，使其满足第三范式。
user用户表，字段id,username,password
role角色表，字段id,name
user_role用户-角色中间表，id,user_id,role_id
像这样，通过第三张表（中间表）来建立用户表和角色表之间的关系，同时又符合范式化的原则，就可以称为第三范式。

4. 反范式化
反范式化指的是通过增加冗余或重复的数据来提高数据库的读性能。

例如：在上例中的user_role用户-角色中间表增加字段role_name。
反范式化可以减少关联查询时，join表的次数。

## 优缺点
### 范式的优缺点
#### 优点：
1.范式化的更新操作通常比反范式化要快。
2.当数据较好的范式化时，就只有很少或者没有重复数据，所以只需要修改更少的数据。
3.范式化的表通常更小，可以更好地放在内存里，所以执行操作会更快。
4.很少有多余的数据意味着检索列表数据时更少需要DISTINCT或者GROUP BY语句。
#### 缺点：
范式化设计的schema的缺点是通常需要关联。稍微复杂一些的查询语句在符合范式的schema上都可能需要至少一次关联，也许更多。这不但代价昂贵，也可能使一些索引策略无效。

例如，范式化可能将列存放在不同的表中，而这些列如果在一个表中本可以属于同一个索引。
### 反法式的优缺点
#### 优点：
反范式化的schema因为所有数据都在一张表中，可以很好地避免关联。如果不需要关联表，则对大部分查询最差的情况－即使表没有使用索引－是全表扫描。当数据比内存大时这可能比关联要快得多，因为这样避免了随机I/O。关联会使的，在执行数据库语句时，使得需要在一个索引中又排序又过滤。如果采用反范式化组织数据将两张表的字段合并一下，并且增加一个索引，就可以不通过关联写出这个查询。
#### 缺点：
表格内的冗余较多，删除数据时候会造成表有些有用的信息丢失。
### 混用范式化和反范式化
完全范式和完全反范式在实际的开发中几乎不存在。

最常见的反范式化数据的方法是复制或者缓存，在不同的表中存储相同的特定列。在MySQL5.0和更新版中，可以使用触发器更新缓存值，这使得实现这样的方案变得更简单。在一个网站实例中，这个网站，允许用户发送消息，并且一些用户是付费用户。现在想查看付费用户最近的10条信息。在user表和message表中都存储用户类型(account_type)而不用完全的反范式化。这避免了完全反范式化的插入和删除问题，因为即使没有消息的时候也绝不会丢失用户的信息。这样也不会把user_message表搞得太大，有利于高效地获取数据。另一个从父表冗余一些数据到子表的理由是排序的需要。缓存衍生值也是有用的。如果需要显示每个用户发了多少消息（类似论坛的），可以每次执行一个昂贵的自查询来计算并显示它；也可以在user表中建一个num_messages列，每当用户发新消息时更新这个值。

# MySQL
--------------

# Redis
--------------

# Oracle
----------------
